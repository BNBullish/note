# -*- coding:utf-8 -*-
__author__ = 'leezp'
__date__ = 20191231
import asyncio
import aiohttp
import aiomultiprocess
import aiofiles
import queue
import datetime
import random
from lxml import etree
import urllib3
import UA_Pool as UApool
import re

# 用于处理 解析域名时出现的上万个子域名，进行去重
# 测试环境：windows 2cpu  url个数：73000
# 消耗时间: 20-35min  很多站都是pending超时，达到最大超时时间5s, 平均每分钟2000-3650站，会持续优化
# 手动去重 73000约需2.5h ,经过对比与手动去重结果基本一致
# 添加代理访问效果更佳

'''
低耦合，只需修改 dic_key,input_file,output_file
dic 按需修改 ,元组表示需要同时满足2个条件，每个列表元祖个数上限为1
'''
asyncio_Semaphore = 500  # 设置最大并发数为500 , linux可设置1000，效率翻倍
dic_key = '1688.com'
input_file = '1688.com_full.txt'
output_file = 'qQq2.txt'

dic = {
    "taobao.com": [
        ('//*[@id="error-notice"]/div[2]/div[1]   没有找到相应的店铺信息',
         '//*[@id="error-notice"]/div[2]/div[3]/ol/li[4]   五秒后跳转至'),
        '/html/body/div/div/p[2]  亲，慢慢来，请先坐下来喝口水！',
        '//*[@id="err"]/div[1]/p[1]  亲，小二正忙，滑动一下马上回来'
    ],
    "tmall.com": [
        ('//*[@id="error-notice"]/div[2]/div[1]   没有找到相应的店铺信息',
         '//*[@id="error-notice"]/div[2]/div[3]/ol/li[4]   五秒后跳转至'),
        '/html/body/div/div/p[2]  亲，慢慢来，请先坐下来喝口水！',
        '//*[@id="err"]/div[1]/p[1]  亲，小二正忙，滑动一下马上回来',
        '//*[@id="dead-page"]/header/div/div/div[2]/p  亲，这是个机器人猖狂的时代，请进行验证证明咱是正常人~',
        '//*[@id="dead-page"]/header/div/div/div[2]/div[2]/p[1]  很抱歉，现在暂时无法处理您的请求'
    ],
    "1688.com": [
        ('//*[@id="content"]/div[1]/div/div/div[2]/div[1]/h3/em[1]   Error 404',
         '//*[@id="content"]/div[1]/div/div/div[2]/div[1]/h3/em[2]   抱歉，您要访问的页面不存在')
    ]
}

q = queue.Queue()
file = open(input_file, encoding='utf-8')
for x in file.readlines():
    url = 'http://' + x.split(' ')[0].strip()
    # url = x.split(' ')[0].strip()
    q.put(url)

title_regex = re.compile(r'<title>([\s\S]*?)</title>')
zh_regex = re.compile(r'[\u4e00-\u9fa5]+')

urllib3.disable_warnings()


# async 定义一个协程
# 淘宝 约124 次出现验证码
# await asyncio.sleep(6)
async def fetch(url):
    sem = asyncio.Semaphore(asyncio_Semaphore)
    async with sem:
        # 最大访问数
        async with aiohttp.ClientSession() as session:
            try:
                async with session.head(url, timeout=5) as response:
                    status = response.status
                    if status == 404 or status == 500 or status == 504:
                        return
                    # res = await response.text()
                    try:
                        # proxy="http://ip:port"
                        async with session.get(url, headers={'User-Agent': random.choice(UApool.data)},
                                               verify_ssl=False,
                                               timeout=5) as resp:
                            # If encoding is None content encoding is autocalculated using Content-Type HTTP header and chardet tool if the header is not provided by server.
                            #  text=await resp.text(encoding=None, errors='ignore') 等价于 content = await  resp.read()  code=chardet.detect(content)['encoding']   text=await resp.text(encoding=code, errors='ignore')
                            text = await resp.text(encoding=None, errors='ignore')
                            html = etree.HTML(text)
                            xp = {}
                            for i in range(len(List)):
                                if type(List[i]).__name__ == "tuple":
                                    xp[str(i)] = html.xpath(List[i][0].split(' ')[0])
                                    xp["100"] = html.xpath(List[i][1].split(' ')[0])
                                else:
                                    xp[str(i)] = html.xpath(List[i].split(' ')[0])
                            flag = False
                            for i in range(len(List)):
                                if type(List[i]).__name__ == "tuple":
                                    if len(xp[str(i)]) > 0 and len(xp[str("100")]) > 0:
                                        if xp[str(i)][0].text.strip() == List[i][0].split(' ')[-1] and xp[
                                            "100"][0].text.strip() == List[i][1].split(' ')[-1]:
                                            flag = True
                                            continue
                                elif len(xp[str(i)]) > 0 and xp[str(i)][0].text:
                                    if xp[str(i)][0].text.strip() == List[i].split(' ')[-1]:
                                        flag = True
                                        continue
                            if flag is False:
                                if title_regex.search(text) and title_regex.search(text).group(1):
                                    s = title_regex.search(text).group(1).strip()
                                    h = zh_regex.findall(s)  # return list
                                    if len(h) > 1 and u'旗舰店' in h[1] and u'天猫' in h[2]:
                                        pass
                                else:
                                    async with aiofiles.open(output_file, 'a', encoding='utf-8') as f:
                                        await f.write("{}  {}".format(url, status) + '\n')
                                        await f.close()
                    except Exception as e:
                        print(e)
                        pass
                    # await check(url, status)
                    # return res
                    finally:
                        print('test speed')
            except Exception as e:
                pass


async def main():
    tasks = []
    while not q.empty():
        url = q.get()
        tasks.append(url)
    async with aiomultiprocess.Pool() as pool:
        result = await pool.map(fetch, tasks)
        # print(result)


List = dic[dic_key]
# asyncio内部用到了select，而select就是系统打开文件数是有限度的，这个其实是操作系统的限制，linux打开文件的最大数默认是1024，windows默认是509，超过了这个值，程序就开始报错
if __name__ == '__main__':
    start_time = datetime.datetime.now()
    print(start_time)
    # event_loop事件循环：程序开启一个无限的循环，当把一些函数注册到事件循环上时，满足事件发生条件即调用相应的函数。
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    end_time = datetime.datetime.now()
    print('消耗时间:{}'.format(end_time - start_time))
